<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="multi-drawable-feature.html">
<link rel="import" href="../../multi-chart/helper/multi-accessor.html">
<link rel="import" href="../../multi-chart/d3-scale/multi-scale.html">
<link rel="import" href="../../multi-chart/d3-scale/d3-scale-property-mixin.html">
<dom-module id="multi-drawable-choropleth">
  <template>
    <multi-accessor accessor="{{valueAccessor}}" path="[[valueAccessorPath]]"></multi-accessor>
    <multi-accessor accessor="{{keyAccessor}}" path="[[keyAccessorPath]]"></multi-accessor>
    <multi-scale 
    	scale="{{colorScale}}"
     	domain="{{domain}}"
     	accessor="{{accessor}}"
     	range="[[range]]"
     	scale-type="[[scaleType]]"
     	elastic="[[elastic]]" 
     	accessor-path="[[accessorPath]]" 
     	padding="[[padding]]" 
     	domain-min="[[domainMin]]" 
     	domain-max="[[domainMax]]" 
     	range="[[range]]"></multi-scale>
    <svg>
      <g id="drawable" slot-svg="slot-g" class="drawable multi-drawable-feature" />
    </svg>
  </template>
  <script>
  (function() {

    /**
     * ## MultiDrawableChoropleth
     *
     * `<multi-drawable-choropleth>` polymer elements responsible for drawing choropleth area in a geo-chart
     *
     * ### Example
     *  ```html
     *     <topojson-feature feature="{{feature}}" data="{{geometries}}" name="counties" url="us.json"></topojson-feature>
     *    <!-- get a topojson mesh for states  -->
     *    <topojson-mesh mesh="{{mesh}}" data="[[geometries]]" name="states"></topojson-mesh>
     *    <!-- a multi-container-geo will expose path and projection -->
     *    <multi-container-geo id="chart" enable-zoom projection="{{projection}}" path="{{path}}" projection-type="[[projectionType]]" scale="{{scale}}">
     *        <!-- group of geo elements. When choropleth changes, contained elements will redraw -->
     *        <multi-container-g>
     *
     *          <!-- draw choropleths with projected to projection -->
     *          <multi-drawable-choropleth data="[[data]]" auto-fit geo-data="[[feature]]" path="[[path]]" attrs="[[choroplethAttrs]]" scale-type="scaleQuantize" domain="[[colorDomain]]" range="[[colorRange]]" color-scale="{{colorScale}}" value-accessor-path="+rate" key-accessor-path="id"></multi-drawable-choropleth>
     *
     *          <!-- show US States -->
     *          <multi-drawable-path path="[[path]]" attrs="[[meshAttrs]]" geo-data="[[mesh]]"></multi-drawable-path>
     *        </multi-container-g>
     *
     *        <!-- display a legend -->
     *        <multi-legend scale="[[colorScale]]" padding="10" title="Unemployment Rate" labels="[[labels]]" label-format=".0%" position="right"> </multi-legend>
     *      </multi-container-geo>
     *  ```
     *
     * @memberof MultiChart
     * @customElement
     * @polymer
     * @appliesMixin MultiChart.mixin.D3ScaleProperty
     * @demo /demo/#multi-choropleth-demo
     **/
    class MultiDrawableChoropleth extends
    MultiChart.mixin.D3ScaleProperty(
      MultiChart.MultiDrawableFeature) {

      static get is() { return 'multi-drawable-choropleth'; }

      static get properties() {
        return {
          /* 
           * `colorScale` scale to use for the choropleth
           */
          colorScale: {
            type: Function,
            notify: true
          },

          /**
           * `valueAccessorPath` path for computing the `valueAccessor` function
           * a value of ´key´ will generate  an accessor function like ´function(d) {return d.key}´ 
           * a value of ´+value.count´ will generate  an accessor function like ´function(d) {return +d.value.count}´ 
           */
          valueAccessorPath: {
            type: String,
            value: 'key'
          },

          /**
           * `valueAccessor` the value accessor function 
           * example function : `d => {return +d.count}`
           */
          valueAccessor: {
            type: Function
          },

          /**
           * `keyAccessorPath` path for computing the `keyAccessor` function
           * a key of ´key´ will generate  an accessor function like ´function(d) {return d.key}´ 
           * a key of ´+key.count´ will generate  an accessor function like ´function(d) {return +d.key.count}´ 
           */
          keyAccessorPath: {
            type: String,
            value: 'key'
          },

          /**
           * `keyAccessor` the value accessor function 
           * example function : `d => {return +d.count}`
           */
          keyAccessor: {
            type: Function
          },

        };
      }

      static get observers() {
        return [
          '_observeData(data, data.*)'
        ];
      }

      /* 
       * `_observeData` will create a map for easy reference while applying the colorScale
       */
      _observeData() {
        if (this.data) {
          const map = d3.map();
          const valueAccessor = this.valueAccessor;
          const keyAccessor = this.keyAccessor;
          let min = Infinity;
          let max = -Infinity;

          this.data.forEach(d => {
            const value = valueAccessor(d);
            map.set(keyAccessor(d), value);
            if (value < min) {
              min = value;
            }
            if (value > max) {
              max = value;
            }
          });

          // Note(cg): we adjust scale domain only if the sacle is marked as elastic
          if(this.elastic) {
            this.domain = [min,max];
          }
          this._map = map;
        }
      }

      draw(data) {
        let chart = super.draw(data);

        return chart
          .attr('title', d=> this._map.get(d.id))
          .attr('fill', d => {
            return this.colorScale(this._map.get(d.id));
          });
      }
    }

    customElements.define(MultiDrawableChoropleth.is, MultiDrawableChoropleth);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

    /* 
     * @namespace MultiChart
     */
    window.MultiChart.MultiDrawableChoropleth = MultiDrawableChoropleth;

  })();
  </script>
</dom-module>