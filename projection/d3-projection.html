<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../multi-chart/helper/config-helper-mixin.html">
<link rel="import" href="../../multi-chart/helper/logger-mixin.html">
<link rel="import" href="d3-projection-mixin.html">
<dom-module id="d3-projection">

  <script>
  (function() {

    const projections = [
      'geoAlbers',
      'geoAlbersUsa',
      'geoAzimuthalEqualArea',
      'geoAzimuthalEquidistant',
      'geoConicConformal',
      'geoConicEqualArea',
      'geoConicEquidistant',
      'geoEquirectangular',
      'geoGnomonic',
      'geoProjection',
      'geoMercator',
      'geoOrthographic',
      'geoStereographic',
      'geoTransverseMercator'
    ];


    /**
     * ## D3Projection
     *
     * `<d3-projection>` a webcompobent for wrapping geo projection as in [d3-geo](https://github.com/d3/d3-geo/blob/master/README.md#_projections)
     * It will expose `projection`.
     *
     * @memberof MultiChart
     * @customElement
     * @polymer
     * @appliesMixin MultiChart.mixin.D3Projection
     * @appliesMixin MultiChart.mixin.ConfigHelper
     * @demo
     **/
    class D3Projection extends 
      MultiChart.mixin.ConfigHelper(
    	 MultiChart.mixin.Logger(
    	 	MultiChart.mixin.D3Projection(
    			Polymer.Element))) {	

      static get is() { return 'd3-projection'; }

      static get properties() {
        return {
          /**
           * `projection` the [projection](https://github.com/d3/d3-geo#projection) generator function
           */
          projection: {
            type: Function,
            notify: true,
            readOnly: true
            // computed: '_computeProjection(projectionType)'
          },

          /**
           * [`scale`](https:github.com/d3/d3-geo#projection_scale)
           */
          scale: {
            type: Number,
            notify: true,
          }
        };
      }

      static get observers() {
        return [
          '_observeType(projectionType)',
          'observeConfig(clipAngle, "clipAngle", "projection", "refresh")',
          'observeConfig(scale, "scale", "projection", "refresh")',
          'observeConfig(precision, "precision", "projection", "refresh")',
          'observeConfig(rotate, "rotate", "projection", "refresh")',
          'observeConfig(clipExtent.*, "clipExtent", "projection", "refresh")',
          'observeConfig(translate.*, "translate", "projection", "refresh")',
          'observeConfig(center.*, "center", "projection", "refresh")',
        ];
      }

      _observeType(projectionType) {
        if (projections.indexOf(projectionType) < 0) {
          this._error('provided projectionType is not a d3.js projection');
        }
        
        const projection = d3[projectionType]();
        this.applyConfig(projection, ['clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'precision']);
        
        // Note(cg): we need a way to tell this component that projection has changed to that we re set properties.
        projection.notifyChange = () => {
          this.syncProperties();
        };

        this._setProjection(projection);
        this.fire('multi-refresh');
      }

      /* 
       * `syncProperties` will sync component properties with projections  
       */
      syncProperties() {
        this.pauseObserver();
         ['clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'precision'].forEach(prop =>{
          if(this.projection[prop]) {
            this[prop] = this.projection[prop]();
          }
         });
        this.fire('multi-refresh');
        this.activateObserver();
      }

      /**
       * [`fitExtent`](https://github.com/d3/d3-geo#projection_fitExtent) Sets the projectionâ€™s scale and translate to fit the specified GeoJSON object in the center of the given `extent`. 
       */
      fitExtent(extent, object) {
        this.projection && this.projection.fitExtent(extent, object);
        this.syncProperties();
        this.fire('multi-refresh');
      }

      /**
       * [`fitSize`](https://github.com/d3/d3-geo#projection_fitSize) A convenience method for projection.fitExtent where the top-left corner of the extent is `[0,0]`.
       */
      fitSize(size, object) {
        this.projection && this.projection.fitSize(size, object);
        this.syncProperties();
        this.fire('multi-refresh');
      }

      /**
       * [`invert`](https://github.com/d3/d3-geo#projection_invert) Returns a new array [longitude, latitude] in degrees representing the unprojected point of the given projected point.
       */
      invert(point) {
        this.projection && this.projection.invert(point);
        this.syncProperties();
        this.fire('multi-refresh');
      }
    }

    customElements.define(D3Projection.is, D3Projection);

    if (!window.MultiChart) {
      window.MultiChart = {};
    }

    /* 
     * @namespace MultiChart
     */
    window.MultiChart.D3Projection = D3Projection;

  })();
  </script>
</dom-module>